#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ËÅîÈÄöÁΩëÁõòÁÆÄÂåñÁªü‰∏ÄÊúçÂä°
TokenÁÆ°ÁêÜ + Êñá‰ª∂‰∏ãËΩΩAPI ‰∏Ä‰ΩìÂåñÊúçÂä°

Author: AI Assistant
Date: 2025-08-27
"""

import json
import logging
import time
import requests
import hashlib
import random
import base64
import threading
import os
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from flask import Flask, request, jsonify, session, redirect, url_for
from dataclasses import dataclass
from functools import wraps
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad

# ÈÖçÁΩÆÊó•Âøó
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# ËÆ§ËØÅÈÖçÁΩÆ
AUTH_CONFIG = {
    'username': 'admin',
    'password': '3150261994',
    'session_timeout': 3600
}

@dataclass
class TokenInfo:
    """Token‰ø°ÊÅØ"""
    token: str
    name: str
    is_active: bool = True
    success_count: int = 0
    error_count: int = 0
    
    def get_success_rate(self) -> float:
        total = self.success_count + self.error_count
        if total == 0:
            return 100.0
        return (self.success_count / total) * 100

class SimpleTokenManager:
    """ÁÆÄÂåñTokenÁÆ°ÁêÜÂô® - Á∫øÁ®ãÂÆâÂÖ®ÁâàÊú¨"""

    def __init__(self):
        self.tokens: List[TokenInfo] = []
        self.current_index = 0
        self.lock = threading.RLock()  # ÂèØÈáçÂÖ•ÈîÅÔºåÊîØÊåÅÂπ∂Âèë
        self.load_tokens()
        
    def load_tokens(self):
        """Âä†ËΩΩtokens"""
        try:
            with open('tokens.json', 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            self.tokens = []
            for token_config in config.get('tokens', []):
                token_info = TokenInfo(
                    token=token_config['token'],
                    name=token_config.get('name', f'Token-{len(self.tokens)+1}'),
                    is_active=token_config.get('is_active', True)
                )
                self.tokens.append(token_info)
            
            logger.info(f"‚úÖ Âä†ËΩΩ‰∫Ü {len(self.tokens)} ‰∏™token")
            
        except FileNotFoundError:
            # ÂàõÂª∫ÈªòËÆ§ÈÖçÁΩÆ
            default_config = {
                "tokens": [
                    {
                        "token": "c4be61c9-3566-4d18-becd-d99f3d0e949e",
                        "name": "‰∏ªToken",
                        "is_active": True
                    }
                ]
            }
            
            with open('tokens.json', 'w', encoding='utf-8') as f:
                json.dump(default_config, f, indent=2, ensure_ascii=False)
            
            logger.info("üìù ÂàõÂª∫‰∫ÜÈªòËÆ§tokenÈÖçÁΩÆÊñá‰ª∂")
            self.load_tokens()
    
    def get_best_token(self) -> Optional[str]:
        """Ëé∑ÂèñÊúÄ‰Ω≥token - Á∫øÁ®ãÂÆâÂÖ®"""
        with self.lock:
            active_tokens = [t for t in self.tokens if t.is_active]
            if not active_tokens:
                return None

            # ÁÆÄÂçïËΩÆËØ¢
            token = active_tokens[self.current_index % len(active_tokens)]
            self.current_index += 1
            return token.token
    
    def report_success(self, token: str):
        """Êä•ÂëäÊàêÂäü - Á∫øÁ®ãÂÆâÂÖ®"""
        with self.lock:
            for t in self.tokens:
                if t.token == token:
                    t.success_count += 1
                    break

    def report_error(self, token: str, error: str):
        """Êä•ÂëäÈîôËØØ - Á∫øÁ®ãÂÆâÂÖ®"""
        with self.lock:
            for t in self.tokens:
                if t.token == token:
                    t.error_count += 1
                    if t.error_count > 10:
                        t.is_active = False
                        logger.warning(f"‚ö†Ô∏è Token {t.name} Ë¢´Á¶ÅÁî®")
                    break

    def add_token(self, token: str, name: str = None) -> bool:
        """Ê∑ªÂä†Êñ∞token - Á∫øÁ®ãÂÆâÂÖ®"""
        with self.lock:
            # Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
            for t in self.tokens:
                if t.token == token:
                    return False

            token_info = TokenInfo(
                token=token,
                name=name or f"Token-{len(self.tokens)+1}"
            )
            self.tokens.append(token_info)
            self.save_tokens()

            logger.info(f"‚úÖ Ê∑ªÂä†Êñ∞token: {token_info.name}")
            return True

    def remove_token(self, token: str) -> bool:
        """Âà†Èô§token - Á∫øÁ®ãÂÆâÂÖ®"""
        with self.lock:
            for i, t in enumerate(self.tokens):
                if t.token == token:
                    removed = self.tokens.pop(i)
                    self.save_tokens()
                    logger.info(f"üóëÔ∏è Âà†Èô§token: {removed.name}")
                    return True
            return False

    def save_tokens(self):
        """‰øùÂ≠òtokensÂà∞ÈÖçÁΩÆÊñá‰ª∂"""
        try:
            config = {
                "tokens": [
                    {
                        "token": token.token,
                        "name": token.name,
                        "is_active": token.is_active
                    }
                    for token in self.tokens
                ]
            }

            with open('tokens.json', 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2, ensure_ascii=False)

        except Exception as e:
            logger.error(f"‚ùå ‰øùÂ≠òtokenÈÖçÁΩÆÂ§±Ë¥•: {e}")

    def get_stats(self) -> Dict:
        """Ëé∑ÂèñÁªüËÆ°‰ø°ÊÅØ - Á∫øÁ®ãÂÆâÂÖ®"""
        with self.lock:
            total_tokens = len(self.tokens)
            active_tokens = len([t for t in self.tokens if t.is_active])

            total_success = sum(t.success_count for t in self.tokens)
            total_errors = sum(t.error_count for t in self.tokens)

            return {
                'total_tokens': total_tokens,
                'active_tokens': active_tokens,
                'total_requests': total_success + total_errors,
                'total_success': total_success,
                'total_errors': total_errors,
                'overall_success_rate': (total_success / (total_success + total_errors) * 100) if (total_success + total_errors) > 0 else 100,
                'tokens': [
                    {
                        'token': t.token,
                        'name': t.name,
                        'is_active': t.is_active,
                        'success_count': t.success_count,
                        'error_count': t.error_count,
                        'success_rate': t.get_success_rate()
                    }
                    for t in self.tokens
                ]
            }

# ==================== ËÅîÈÄöÁΩëÁõòAPIÊ†∏ÂøÉÁ±ª ====================

class WoPanCrypto:
    """ËÅîÈÄöÁΩëÁõòÂä†ÂØÜÂ∑•ÂÖ∑"""

    def __init__(self, client_secret: str = "XFmi9GS2hzk98jGX"):
        self.key = client_secret.encode('utf-8')
        self.iv = b"wNSOYIB1k1DjY5lA"
        self.access_key = None

    def set_access_token(self, token: str):
        """ËÆæÁΩÆËÆøÈóÆ‰ª§ÁâåÁî®‰∫éÂä†ÂØÜ"""
        if len(token) >= 16:
            self.access_key = token[:16].encode('utf-8')

    def encrypt(self, content: str, channel: str) -> str:
        """Âä†ÂØÜÂÜÖÂÆπ"""
        key = self.key if channel == "api-user" else self.access_key
        if key is None:
            key = self.key

        try:
            cipher = AES.new(key, AES.MODE_CBC, self.iv)
            padded_data = pad(content.encode('utf-8'), AES.block_size)
            encrypted = cipher.encrypt(padded_data)
            return base64.b64encode(encrypted).decode('utf-8')
        except Exception as e:
            logger.debug(f"Âä†ÂØÜÂ§±Ë¥•: {e}")
            return content

    def decrypt(self, encrypted_data: str, channel: str) -> str:
        """Ëß£ÂØÜÂÜÖÂÆπ"""
        key = self.key if channel == "api-user" else self.access_key
        if key is None:
            key = self.key

        try:
            encrypted_bytes = base64.b64decode(encrypted_data)
            cipher = AES.new(key, AES.MODE_CBC, self.iv)
            decrypted = cipher.decrypt(encrypted_bytes)
            unpadded = unpad(decrypted, AES.block_size)
            return unpadded.decode('utf-8')
        except Exception as e:
            logger.debug(f"Ëß£ÂØÜÂ§±Ë¥•: {e}")
            return encrypted_data


class WoPanFile:
    """ËÅîÈÄöÁΩëÁõòÊñá‰ª∂ÂØπË±°"""

    def __init__(self, data: Dict):
        self.fid = data.get('fid', '')
        self.creator = data.get('creator', '')
        self.preview_url = data.get('previewUrl', '')
        self.space_type = data.get('spaceType', '0')
        self.load_info = data.get('loadInfo', '')
        self.shooting_time = data.get('shootingTime', '')
        self.type = data.get('type', 1)  # 0: Êñá‰ª∂Â§π, 1: Êñá‰ª∂
        self.family_id = data.get('familyId', 0)
        self.size = data.get('size', 0)
        self.create_time = data.get('createTime', '')
        self.name = data.get('name', '')
        self.id = data.get('id', '')
        self.thumb_url = data.get('thumbUrl', '')
        self.file_type = data.get('fileType', '')
        self.is_collected = data.get('isCollected', 0)

    @property
    def is_folder(self) -> bool:
        """ÊòØÂê¶‰∏∫Êñá‰ª∂Â§π"""
        return self.type == 0

    @property
    def formatted_create_time(self) -> str:
        """Ê†ºÂºèÂåñÁöÑÂàõÂª∫Êó∂Èó¥"""
        if len(self.create_time) == 14:  # YYYYMMDDHHMMSS
            try:
                dt = datetime.strptime(self.create_time, '%Y%m%d%H%M%S')
                return dt.strftime('%Y-%m-%d %H:%M:%S')
            except:
                return self.create_time
        return self.create_time

    def to_dict(self) -> Dict:
        """ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏"""
        return {
            'id': self.id,
            'fid': self.fid,
            'name': self.name,
            'size': self.size,
            'type': 'folder' if self.is_folder else 'file',
            'create_time': self.formatted_create_time,
            'file_type': self.file_type,
            'thumb_url': self.thumb_url
        }


class WoPanRealTimeAPI:
    """ËÅîÈÄöÁΩëÁõòÂÆûÊó∂API"""

    DEFAULT_CLIENT_ID = "1001000021"
    DEFAULT_CLIENT_SECRET = "XFmi9GS2hzk98jGX"
    DEFAULT_BASE_URL = "https://panservice.mail.wo.cn"
    DEFAULT_UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.37"
    CHANNEL_WO_HOME = "wohome"

    def __init__(self, access_token: str):
        self.access_token = access_token
        self.crypto = WoPanCrypto(self.DEFAULT_CLIENT_SECRET)
        self.crypto.set_access_token(access_token)

        # ËÆæÁΩÆsession
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': self.DEFAULT_UA,
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Origin': 'https://pan.wo.cn',
            'Referer': 'https://pan.wo.cn/',
            'Accesstoken': self.access_token
        })

    def _calc_header(self, channel: str, key: str) -> Dict:
        """ËÆ°ÁÆóËØ∑Ê±ÇÂ§¥"""
        res_time = int(time.time() * 1000)
        req_seq = random.randint(100000, 108999)
        version = ""

        sign_content = f"{key}{res_time}{req_seq}{channel}{version}"
        sign = hashlib.md5(sign_content.encode()).hexdigest()

        return {
            "key": key,
            "resTime": res_time,
            "reqSeq": req_seq,
            "channel": channel,
            "sign": sign,
            "version": version
        }

    def _new_body(self, channel: str, param: Dict, other: Dict) -> Dict:
        """ÊûÑÂª∫ËØ∑Ê±Ç‰Ωì"""
        if not param:
            return other

        param_json = json.dumps(param, separators=(',', ':'))
        encrypted_param = self.crypto.encrypt(param_json, channel)

        body = other.copy()
        body["param"] = encrypted_param
        return body

    def get_folder_contents(self, parent_id: str = "0", space_type: str = "0",
                           page_size: int = 100) -> Tuple[bool, List[WoPanFile]]:
        """Ëé∑ÂèñÊñá‰ª∂Â§πÂÜÖÂÆπ"""
        url = f"{self.DEFAULT_BASE_URL}/{self.CHANNEL_WO_HOME}/dispatcher"

        headers = self.session.headers.copy()
        headers['Accesstoken'] = self.access_token
        request_header = self._calc_header(self.CHANNEL_WO_HOME, "QueryAllFiles")

        param = {
            "spaceType": space_type,
            "parentDirectoryId": parent_id,
            "pageNum": 0,
            "pageSize": page_size,
            "sortRule": 1,
            "clientId": self.DEFAULT_CLIENT_ID
        }

        other = {"secret": True}
        request_body = self._new_body(self.CHANNEL_WO_HOME, param, other)

        request_data = {
            "header": request_header,
            "body": request_body
        }

        try:
            response = self.session.post(url, json=request_data, headers=headers, timeout=30)

            if response.status_code != 200:
                return False, []

            result = response.json()

            if result.get('STATUS') != '200':
                return False, []

            rsp = result.get('RSP', {})
            if rsp.get('RSP_CODE') != '0000':
                return False, []

            data = rsp.get('DATA', '')
            if isinstance(data, str):
                decrypted_text = self.crypto.decrypt(data, self.CHANNEL_WO_HOME)

                try:
                    parsed_data = json.loads(decrypted_text)
                    files_data = parsed_data.get('files', [])
                    files = [WoPanFile(file_data) for file_data in files_data]
                    return True, files
                except json.JSONDecodeError:
                    return False, []
            else:
                return False, []

        except Exception as e:
            logger.error(f"ÂÆûÊó∂ËØ∑Ê±ÇÂºÇÂ∏∏: {e}")
            return False, []

    def find_file_by_name(self, folder_name: str, file_name: str) -> Optional[WoPanFile]:
        """Âú®ÊåáÂÆöÊñá‰ª∂Â§π‰∏≠Êü•ÊâæÊñá‰ª∂ÔºàÂÖºÂÆπÊóßÁâàÊú¨Ôºâ"""
        return self.find_file_by_path([folder_name], file_name)

    def find_file_by_path(self, folder_path: List[str], file_name: str) -> Optional[WoPanFile]:
        """Âú®ÊåáÂÆöË∑ØÂæÑ‰∏≠Êü•ÊâæÊñá‰ª∂ - ÊîØÊåÅÂ§öÁ∫ßÁõÆÂΩï"""
        current_folder_id = "0"  # ‰ªéÊ†πÁõÆÂΩïÂºÄÂßã

        # ÈÄêÁ∫ßÊü•ÊâæÊñá‰ª∂Â§π
        for folder_name in folder_path:
            logger.debug(f"üîç Êü•ÊâæÊñá‰ª∂Â§π: {folder_name} (ÂΩìÂâçID: {current_folder_id})")

            success, files = self.get_folder_contents(current_folder_id)
            if not success:
                logger.error(f"‚ùå Ëé∑ÂèñÊñá‰ª∂Â§πÂÜÖÂÆπÂ§±Ë¥•: {current_folder_id}")
                return None

            # Âú®ÂΩìÂâçÁ∫ßÂà´Êü•ÊâæÁõÆÊ†áÊñá‰ª∂Â§π
            target_folder = None
            for file in files:
                if file.is_folder and file.name == folder_name:
                    target_folder = file
                    break

            if not target_folder:
                logger.warning(f"‚ö†Ô∏è Êú™ÊâæÂà∞Êñá‰ª∂Â§π: {folder_name}")
                return None

            current_folder_id = target_folder.id
            logger.debug(f"‚úÖ ÊâæÂà∞Êñá‰ª∂Â§π: {folder_name} (ID: {current_folder_id})")

        # Âú®ÊúÄÁªàÊñá‰ª∂Â§π‰∏≠Êü•ÊâæÊñá‰ª∂
        logger.debug(f"üîç Âú®ÊúÄÁªàÊñá‰ª∂Â§π‰∏≠Êü•ÊâæÊñá‰ª∂: {file_name} (Êñá‰ª∂Â§πID: {current_folder_id})")
        success, folder_files = self.get_folder_contents(current_folder_id)
        if not success:
            logger.error(f"‚ùå Ëé∑ÂèñÊúÄÁªàÊñá‰ª∂Â§πÂÜÖÂÆπÂ§±Ë¥•: {current_folder_id}")
            return None

        for file in folder_files:
            if not file.is_folder and file.name == file_name:
                logger.info(f"‚úÖ ÊâæÂà∞Êñá‰ª∂: {file_name} (FID: {file.fid})")
                return file

        logger.warning(f"‚ö†Ô∏è Êú™ÊâæÂà∞Êñá‰ª∂: {file_name}")
        return None


class WoPanDownloader:
    """ËÅîÈÄöÁΩëÁõò‰∏ãËΩΩÂô®"""

    DEFAULT_CLIENT_ID = "1001000021"
    DEFAULT_CLIENT_SECRET = "XFmi9GS2hzk98jGX"
    DEFAULT_BASE_URL = "https://panservice.mail.wo.cn"
    DEFAULT_UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.37"
    CHANNEL_WO_HOME = "wohome"

    def __init__(self, access_token: str):
        self.access_token = access_token
        self.crypto = WoPanCrypto(self.DEFAULT_CLIENT_SECRET)
        self.crypto.set_access_token(access_token)

        # ËÆæÁΩÆsession
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': self.DEFAULT_UA,
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'Origin': 'https://pan.wo.cn',
            'Referer': 'https://pan.wo.cn/',
            'Accesstoken': self.access_token
        })

    def _calc_header(self, channel: str, key: str) -> Dict:
        """ËÆ°ÁÆóËØ∑Ê±ÇÂ§¥"""
        res_time = int(time.time() * 1000)
        req_seq = random.randint(100000, 108999)
        version = ""

        sign_content = f"{key}{res_time}{req_seq}{channel}{version}"
        sign = hashlib.md5(sign_content.encode()).hexdigest()

        return {
            "key": key,
            "resTime": res_time,
            "reqSeq": req_seq,
            "channel": channel,
            "sign": sign,
            "version": version
        }

    def _new_body(self, channel: str, param: Dict, other: Dict) -> Dict:
        """ÊûÑÂª∫ËØ∑Ê±Ç‰Ωì"""
        if not param:
            return other

        param_json = json.dumps(param, separators=(',', ':'))
        encrypted_param = self.crypto.encrypt(param_json, channel)

        body = other.copy()
        body["param"] = encrypted_param
        return body

    def get_download_url_v2(self, fids: List[str]) -> Tuple[bool, any]:
        """Ëé∑Âèñ‰∏ãËΩΩÈìæÊé•V2"""
        url = f"{self.DEFAULT_BASE_URL}/{self.CHANNEL_WO_HOME}/dispatcher"

        headers = self.session.headers.copy()
        headers['Accesstoken'] = self.access_token
        request_header = self._calc_header(self.CHANNEL_WO_HOME, "GetDownloadUrlV2")

        param = {
            "type": "1",
            "fidList": fids,
            "clientId": self.DEFAULT_CLIENT_ID
        }

        other = {"secret": True}
        request_body = self._new_body(self.CHANNEL_WO_HOME, param, other)

        request_data = {
            "header": request_header,
            "body": request_body
        }

        try:
            response = self.session.post(url, json=request_data, headers=headers, timeout=30)

            if response.status_code != 200:
                return False, f"HTTPÈîôËØØ: {response.status_code}"

            result = response.json()

            if result.get('STATUS') != '200':
                return False, f"APIÈîôËØØ: {result.get('STATUS')} - {result.get('MSG')}"

            rsp = result.get('RSP', {})
            if rsp.get('RSP_CODE') != '0000':
                return False, f"ÂìçÂ∫îÈîôËØØ: {rsp.get('RSP_CODE')} - {rsp.get('RSP_DESC')}"

            data = rsp.get('DATA', '')
            if isinstance(data, str):
                decrypted_text = self.crypto.decrypt(data, self.CHANNEL_WO_HOME)

                try:
                    parsed_data = json.loads(decrypted_text)
                    return True, parsed_data
                except json.JSONDecodeError as e:
                    return False, f"JSONËß£ÊûêÂ§±Ë¥•: {e}"
            else:
                return False, "Êú™Ëé∑ÂèñÂà∞ÊúâÊïàÊï∞ÊçÆ"

        except Exception as e:
            return False, f"ËØ∑Ê±ÇÂºÇÂ∏∏: {e}"


# ÂàõÂª∫ÂÖ®Â±ÄÁÆ°ÁêÜÂô®
token_manager = SimpleTokenManager()

# ÂàõÂª∫FlaskÂ∫îÁî®
app = Flask(__name__)
app.secret_key = 'simple-unified-service-2025'

def require_auth(f):
    """ËÆ§ËØÅË£ÖÈ•∞Âô®"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        # APIÁ´ØÁÇπË∑≥ËøáËÆ§ËØÅ
        if request.path.startswith('/api/') or request.path == '/health':
            return f(*args, **kwargs)
        
        if 'logged_in' not in session or not session['logged_in']:
            if request.path == '/login':
                return f(*args, **kwargs)
            return redirect(url_for('login'))
        
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    """ÁôªÂΩï"""
    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')
        
        if username == AUTH_CONFIG['username'] and password == AUTH_CONFIG['password']:
            session['logged_in'] = True
            session['username'] = username
            logger.info(f"‚úÖ Áî®Êà∑ {username} ÁôªÂΩïÊàêÂäü")
            return redirect(url_for('index'))
        else:
            error = "Áî®Êà∑ÂêçÊàñÂØÜÁ†ÅÈîôËØØ"
    else:
        error = None
    
    return f"""
<!DOCTYPE html>
<html>
<head>
    <title>Áªü‰∏ÄÊúçÂä° - ÁôªÂΩï</title>
    <style>
        body {{ font-family: Arial; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
               margin: 0; height: 100vh; display: flex; align-items: center; justify-content: center; }}
        .login {{ background: white; padding: 40px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); }}
        .login h1 {{ text-align: center; color: #333; }}
        .form-group {{ margin: 20px 0; }}
        .form-group label {{ display: block; margin-bottom: 5px; }}
        .form-group input {{ width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 5px; }}
        .btn {{ width: 100%; padding: 12px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }}
        .error {{ color: red; margin: 10px 0; }}
    </style>
</head>
<body>
    <div class="login">
        <h1>Áªü‰∏ÄÊúçÂä°</h1>
        {f'<div class="error">{error}</div>' if error else ''}
        <form method="POST">
            <div class="form-group">
                <label>Áî®Êà∑Âêç</label>
                <input type="text" name="username" required>
            </div>
            <div class="form-group">
                <label>ÂØÜÁ†Å</label>
                <input type="password" name="password" required>
            </div>
            <button type="submit" class="btn">ÁôªÂΩï</button>
        </form>
    </div>
</body>
</html>
    """

@app.route('/')
@require_auth
def index():
    """‰∏ªÈ°µ"""
    username = session.get('username', 'Unknown')
    stats = token_manager.get_stats()
    
    return f"""
<!DOCTYPE html>
<html>
<head>
    <title>Áªü‰∏ÄÊúçÂä°</title>
    <style>
        body {{ font-family: Arial; margin: 20px; background: #f5f5f5; }}
        .container {{ max-width: 1000px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }}
        .header {{ display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }}
        .stats {{ display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin: 20px 0; }}
        .stat {{ background: #f8f9fa; padding: 15px; border-radius: 5px; text-align: center; }}
        .stat-number {{ font-size: 2em; font-weight: bold; color: #007bff; }}
        .api-section {{ background: #e3f2fd; padding: 20px; border-radius: 5px; margin: 20px 0; }}
        .token-section {{ background: #f8f9fa; padding: 20px; border-radius: 5px; margin: 20px 0; }}
        .token-item {{ background: white; margin: 10px 0; padding: 15px; border-radius: 5px; border-left: 4px solid #007bff; }}
        .token-active {{ border-left-color: #28a745; }}
        .token-inactive {{ border-left-color: #dc3545; }}
        .add-token {{ background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 10px 0; }}
        .btn {{ padding: 8px 15px; background: #dc3545; color: white; text-decoration: none; border-radius: 5px; border: none; cursor: pointer; }}
        .btn-primary {{ background: #007bff; }}
        .btn-success {{ background: #28a745; }}
        .btn-danger {{ background: #dc3545; }}
        input {{ padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 3px; width: 200px; }}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Áªü‰∏ÄÊúçÂä°</h1>
            <div>
                <span>üë§ {username}</span>
                <a href="/logout" class="btn">ÁôªÂá∫</a>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-number">{stats['total_tokens']}</div>
                <div>ÊÄªTokenÊï∞</div>
            </div>
            <div class="stat">
                <div class="stat-number">{stats['active_tokens']}</div>
                <div>Ê¥ªË∑ÉToken</div>
            </div>
            <div class="stat">
                <div class="stat-number">{stats['total_success']}</div>
                <div>ÊàêÂäüËØ∑Ê±Ç</div>
            </div>
            <div class="stat">
                <div class="stat-number">{stats['total_errors']}</div>
                <div>Â§±Ë¥•ËØ∑Ê±Ç</div>
            </div>
        </div>

        <div class="token-section">
            <h3>üîë TokenÁÆ°ÁêÜ</h3>

            <div class="add-token">
                <h4>‚ûï Ê∑ªÂä†Êñ∞Token</h4>
                <form method="POST" action="/add_token">
                    <input type="text" name="token" placeholder="ËæìÂÖ•Token" required>
                    <input type="text" name="name" placeholder="TokenÂêçÁß∞">
                    <button type="submit" class="btn btn-success">Ê∑ªÂä†Token</button>
                </form>
            </div>

            <div id="tokenList">
                <!-- TokenÂàóË°®Â∞ÜÂú®ËøôÈáåÊòæÁ§∫ -->
            </div>
        </div>
        
        <div class="api-section">
            <h3>üìã APIÁ´ØÁÇπ</h3>
            <p><strong>GET /api/download/?url=folder/filename</strong> - Ëé∑ÂèñÊñá‰ª∂‰∏ãËΩΩÂú∞ÂùÄ</p>
            <p><strong>GET /api/folders</strong> - Ëé∑ÂèñÊñá‰ª∂Â§πÂàóË°®</p>
            <p><strong>GET /api/files?folder=name</strong> - Ëé∑ÂèñÊñá‰ª∂ÂàóË°®</p>
            <p><strong>GET /health</strong> - ÂÅ•Â∫∑Ê£ÄÊü•</p>
        </div>

    <script>
        // È°µÈù¢Âä†ËΩΩÊó∂Ëé∑ÂèñTokenÂàóË°®
        window.onload = function() {{
            refreshTokenList();
        }};

        function refreshTokenList() {{
            fetch('/api/token/stats')
                .then(response => response.json())
                .then(data => {{
                    if (data.success) {{
                        updateTokenList(data.data.tokens);
                    }}
                }})
                .catch(error => console.error('Error:', error));
        }}

        function updateTokenList(tokens) {{
            const listDiv = document.getElementById('tokenList');
            listDiv.innerHTML = tokens.map(token => `
                <div class="token-item ${{token.is_active ? 'token-active' : 'token-inactive'}}">
                    <strong>${{token.name}}</strong>
                    <span style="color: ${{token.is_active ? '#28a745' : '#dc3545'}};">
                        ${{token.is_active ? 'üü¢ Ê¥ªË∑É' : 'üî¥ Á¶ÅÁî®'}}
                    </span>
                    <br>
                    <small>Token: ${{token.token.substring(0, 20)}}...</small><br>
                    <small>ÊàêÂäü: ${{token.success_count}} | Â§±Ë¥•: ${{token.error_count}} | ÊàêÂäüÁéá: ${{token.success_rate.toFixed(1)}}%</small>
                    <div style="margin-top: 10px;">
                        <button class="btn btn-danger" onclick="removeToken('${{token.token}}')">Âà†Èô§</button>
                    </div>
                </div>
            `).join('');
        }}

        function removeToken(token) {{
            if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™TokenÂêóÔºü')) return;

            fetch('/remove_token', {{
                method: 'POST',
                headers: {{ 'Content-Type': 'application/x-www-form-urlencoded' }},
                body: 'token=' + encodeURIComponent(token)
            }})
            .then(response => {{
                if (response.ok) {{
                    alert('TokenÂà†Èô§ÊàêÂäü');
                    refreshTokenList();
                    location.reload(); // Âà∑Êñ∞È°µÈù¢Êõ¥Êñ∞ÁªüËÆ°
                }} else {{
                    alert('Âà†Èô§Â§±Ë¥•');
                }}
            }})
            .catch(error => {{
                console.error('Error:', error);
                alert('Âà†Èô§Â§±Ë¥•');
            }});
        }}

        // ÊØè30ÁßíËá™Âä®Âà∑Êñ∞TokenÂàóË°®
        setInterval(refreshTokenList, 30000);
    </script>
</body>
</html>
    """

@app.route('/logout')
@require_auth
def logout():
    """ÁôªÂá∫"""
    session.clear()
    return redirect(url_for('login'))


@app.route('/add_token', methods=['POST'])
@require_auth
def add_token():
    """Ê∑ªÂä†Token"""
    token = request.form.get('token')
    name = request.form.get('name')

    if not token:
        return "Token‰∏çËÉΩ‰∏∫Á©∫", 400

    if token_manager.add_token(token, name):
        return redirect(url_for('index'))
    else:
        return "TokenÂ∑≤Â≠òÂú®", 400


@app.route('/remove_token', methods=['POST'])
@require_auth
def remove_token():
    """Âà†Èô§Token"""
    token = request.form.get('token')

    if not token:
        return "Token‰∏çËÉΩ‰∏∫Á©∫", 400

    if token_manager.remove_token(token):
        return "Âà†Èô§ÊàêÂäü", 200
    else:
        return "Token‰∏çÂ≠òÂú®", 404

# ==================== APIÁ´ØÁÇπ ====================

@app.route('/api/token/get')
def api_get_token():
    """Ëé∑ÂèñToken"""
    token = token_manager.get_best_token()
    if token:
        return jsonify({
            'code': 200,
            'success': True,
            'data': {'token': token}
        })
    else:
        return jsonify({
            'code': 404,
            'success': False,
            'error': 'Ê≤°ÊúâÂèØÁî®ÁöÑtoken'
        }), 404


@app.route('/api/token/stats')
def api_token_stats():
    """Ëé∑ÂèñTokenÁªüËÆ°‰ø°ÊÅØ"""
    stats = token_manager.get_stats()
    return jsonify({
        'code': 200,
        'success': True,
        'data': stats
    })


@app.route('/api/download/')
def api_download():
    """Ëé∑Âèñ‰∏ãËΩΩÂú∞ÂùÄ - ÈõÜÊàêÁúüÂÆû‰∏ãËΩΩÈÄªËæë"""
    url_param = request.args.get('url')
    if not url_param:
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'Áº∫Â∞ëurlÂèÇÊï∞'
        }), 400

    # Ëß£ÊûêurlÂèÇÊï∞ - ÊîØÊåÅÂ§öÁ∫ßÁõÆÂΩï
    url_parts = url_param.split('/')
    if len(url_parts) < 2:
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'URLÊ†ºÂºèÈîôËØØÔºåËá≥Â∞ëÈúÄË¶ÅÔºöfolder/filename'
        }), 400

    # ÊúÄÂêé‰∏Ä‰∏™ÊòØÊñá‰ª∂ÂêçÔºåÂâçÈù¢ÁöÑÈÉΩÊòØÊñá‰ª∂Â§πË∑ØÂæÑ
    file_name = url_parts[-1]
    folder_path = url_parts[:-1]  # Êñá‰ª∂Â§πË∑ØÂæÑÊï∞ÁªÑ

    # Ëé∑ÂèñToken
    token = token_manager.get_best_token()
    if not token:
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'Ê≤°ÊúâÂèØÁî®ÁöÑToken'
        }), 500

    try:
        # ÂàõÂª∫ÂÆûÊó∂APIÂÆû‰æã
        realtime_api = WoPanRealTimeAPI(token)

        # Êü•ÊâæÊñá‰ª∂ - ÊîØÊåÅÂ§öÁ∫ßÁõÆÂΩï
        folder_path_str = '/'.join(folder_path)
        logger.info(f"üîç Êü•ÊâæÊñá‰ª∂: {folder_path_str}/{file_name}")
        file_obj = realtime_api.find_file_by_path(folder_path, file_name)

        if not file_obj:
            token_manager.report_error(token, f"Êñá‰ª∂Êú™ÊâæÂà∞: {folder_path_str}/{file_name}")
            return jsonify({
                'code': 401,
                'success': False,
                'error': 'Êñá‰ª∂Êú™ÊâæÂà∞',
                'message': f"Âú®Ë∑ØÂæÑ '{folder_path_str}' ‰∏≠Êú™ÊâæÂà∞Êñá‰ª∂ '{file_name}'"
            }), 404

        # Ëé∑ÂèñÊñá‰ª∂FID
        fid = file_obj.fid
        if not fid:
            token_manager.report_error(token, "Êñá‰ª∂FID‰∏∫Á©∫")
            return jsonify({
                'code': 401,
                'success': False,
                'error': 'Êñá‰ª∂FID‰∏∫Á©∫'
            }), 500

        # ÂàõÂª∫‰∏ãËΩΩÂô®ÂÆû‰æã
        downloader = WoPanDownloader(token)

        # Ëé∑Âèñ‰∏ãËΩΩÈìæÊé•
        logger.info(f"üì• Ëé∑Âèñ‰∏ãËΩΩÈìæÊé•: FID={fid}")
        success, download_data = downloader.get_download_url_v2([fid])

        # Ê∑ªÂä†ËØ¶ÁªÜÁöÑË∞ÉËØïÊó•Âøó
        logger.info(f"üîç ‰∏ãËΩΩAPIË∞ÉÁî®ÁªìÊûú: success={success}")
        logger.info(f"üîç ‰∏ãËΩΩAPIÂìçÂ∫îÊï∞ÊçÆ: {download_data}")

        if not success:
            token_manager.report_error(token, f"Ëé∑Âèñ‰∏ãËΩΩÈìæÊé•Â§±Ë¥•: {download_data}")
            logger.error(f"‚ùå ‰∏ãËΩΩÈìæÊé•Ëé∑ÂèñÂ§±Ë¥•: {download_data}")
            return jsonify({
                'code': 401,
                'success': False,
                'error': 'Ëé∑Âèñ‰∏ãËΩΩÈìæÊé•Â§±Ë¥•',
                'message': str(download_data)
            }), 500

        # ÊèêÂèñ‰∏ãËΩΩURL - Ê†πÊçÆÂÆûÈôÖÂìçÂ∫îÁªìÊûÑ
        download_url = None
        if isinstance(download_data, dict):
            # Ê£ÄÊü•ÊòØÂê¶ÊúâlistÂ≠óÊÆµ
            file_list = download_data.get('list', [])
            if file_list and len(file_list) > 0:
                # ‰ªéÁ¨¨‰∏Ä‰∏™Êñá‰ª∂È°π‰∏≠Ëé∑ÂèñdownloadUrl
                first_file = file_list[0]
                download_url = first_file.get('downloadUrl')
            else:
                # Â§áÁî®ÊñπÊ°àÔºöÁõ¥Êé•‰ªéÊ†πÁ∫ßÂà´Êü•Êâæ
                download_url = (download_data.get('downloadUrl') or
                              download_data.get('url') or
                              download_data.get('download_url'))

        if not download_url:
            token_manager.report_error(token, "‰∏ãËΩΩÈìæÊé•‰∏∫Á©∫")
            return jsonify({
                'code': 401,
                'success': False,
                'error': '‰∏ãËΩΩÈìæÊé•‰∏∫Á©∫',
                'message': 'Êó†Ê≥ï‰ªéAPIÂìçÂ∫î‰∏≠ÊèêÂèñ‰∏ãËΩΩÈìæÊé•'
            }), 500

        # Êä•ÂëäÊàêÂäü
        token_manager.report_success(token)
        logger.info(f"‚úÖ ÊàêÂäüËé∑Âèñ‰∏ãËΩΩÈìæÊé•: {file_name}")

        return jsonify({
            'code': 200,
            'information': 'xinjie',
            'url': download_url
        })

    except Exception as e:
        token_manager.report_error(token, f"‰∏ãËΩΩAPIÂºÇÂ∏∏: {str(e)}")
        logger.error(f"‚ùå ‰∏ãËΩΩAPIÂºÇÂ∏∏: {e}")
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ',
            'message': str(e)
        }), 500


@app.route('/api/folders')
def api_folders():
    """Ëé∑ÂèñÊñá‰ª∂Â§πÂàóË°®"""
    # Ëé∑ÂèñToken
    token = token_manager.get_best_token()
    if not token:
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'Ê≤°ÊúâÂèØÁî®ÁöÑToken'
        }), 500

    try:
        # ÂàõÂª∫ÂÆûÊó∂APIÂÆû‰æã
        realtime_api = WoPanRealTimeAPI(token)

        # Ëé∑ÂèñÊ†πÁõÆÂΩïÂÜÖÂÆπ
        logger.info("üîç Ëé∑ÂèñÊñá‰ª∂Â§πÂàóË°®")
        success, root_files = realtime_api.get_folder_contents("0")

        if not success:
            token_manager.report_error(token, "Ëé∑ÂèñÊñá‰ª∂Â§πÂàóË°®Â§±Ë¥•")
            return jsonify({
                'code': 401,
                'success': False,
                'error': 'Ëé∑ÂèñÊñá‰ª∂Â§πÂàóË°®Â§±Ë¥•'
            }), 500

        # ËøáÊª§Âá∫Êñá‰ª∂Â§π
        folders = [f.name for f in root_files if f.is_folder]

        token_manager.report_success(token)
        logger.info(f"‚úÖ ÊàêÂäüËé∑Âèñ {len(folders)} ‰∏™Êñá‰ª∂Â§π")

        return jsonify({
            'code': 200,
            'success': True,
            'data': folders,
            'count': len(folders),
            'source': 'realtime'
        })

    except Exception as e:
        token_manager.report_error(token, f"Êñá‰ª∂Â§πAPIÂºÇÂ∏∏: {str(e)}")
        logger.error(f"‚ùå Êñá‰ª∂Â§πAPIÂºÇÂ∏∏: {e}")
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ',
            'message': str(e)
        }), 500


@app.route('/api/files')
def api_files():
    """Ëé∑ÂèñÊñá‰ª∂ÂàóË°®"""
    folder_name = request.args.get('folder')
    if not folder_name:
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'Áº∫Â∞ëfolderÂèÇÊï∞'
        }), 400

    # Ëé∑ÂèñToken
    token = token_manager.get_best_token()
    if not token:
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'Ê≤°ÊúâÂèØÁî®ÁöÑToken'
        }), 500

    try:
        # ÂàõÂª∫ÂÆûÊó∂APIÂÆû‰æã
        realtime_api = WoPanRealTimeAPI(token)

        # Ëé∑ÂèñÊ†πÁõÆÂΩïÂÜÖÂÆπÔºåÊâæÂà∞ÁõÆÊ†áÊñá‰ª∂Â§π
        logger.info(f"üîç Ëé∑ÂèñÊñá‰ª∂Â§πÂÜÖÂÆπ: {folder_name}")
        success, root_files = realtime_api.get_folder_contents("0")

        if not success:
            token_manager.report_error(token, "Ëé∑ÂèñÊ†πÁõÆÂΩïÂ§±Ë¥•")
            return jsonify({
                'code': 401,
                'success': False,
                'error': 'Ëé∑ÂèñÊ†πÁõÆÂΩïÂ§±Ë¥•'
            }), 500

        # Êü•ÊâæÁõÆÊ†áÊñá‰ª∂Â§π
        target_folder = None
        for file in root_files:
            if file.is_folder and file.name == folder_name:
                target_folder = file
                break

        if not target_folder:
            token_manager.report_error(token, f"Êñá‰ª∂Â§πÊú™ÊâæÂà∞: {folder_name}")
            return jsonify({
                'code': 401,
                'success': False,
                'error': 'Êñá‰ª∂Â§πÊú™ÊâæÂà∞',
                'message': f"Êú™ÊâæÂà∞Êñá‰ª∂Â§π '{folder_name}'"
            }), 404

        # Ëé∑ÂèñÊñá‰ª∂Â§πÂÜÖÂÆπ
        success, folder_files = realtime_api.get_folder_contents(target_folder.id)

        if not success:
            token_manager.report_error(token, f"Ëé∑ÂèñÊñá‰ª∂Â§πÂÜÖÂÆπÂ§±Ë¥•: {folder_name}")
            return jsonify({
                'code': 401,
                'success': False,
                'error': 'Ëé∑ÂèñÊñá‰ª∂Â§πÂÜÖÂÆπÂ§±Ë¥•'
            }), 500

        # ËΩ¨Êç¢‰∏∫Â≠óÂÖ∏Ê†ºÂºè
        files_data = [f.to_dict() for f in folder_files]

        token_manager.report_success(token)
        logger.info(f"‚úÖ ÊàêÂäüËé∑Âèñ {len(files_data)} ‰∏™Êñá‰ª∂")

        return jsonify({
            'code': 200,
            'success': True,
            'data': {
                'folder': folder_name,
                'file_count': len(files_data),
                'source': 'realtime',
                'files': files_data
            }
        })

    except Exception as e:
        token_manager.report_error(token, f"Êñá‰ª∂APIÂºÇÂ∏∏: {str(e)}")
        logger.error(f"‚ùå Êñá‰ª∂APIÂºÇÂ∏∏: {e}")
        return jsonify({
            'code': 401,
            'success': False,
            'error': 'ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ',
            'message': str(e)
        }), 500


@app.route('/health')
def health():
    """ÂÅ•Â∫∑Ê£ÄÊü•"""
    return jsonify({
        'status': 'healthy',
        'service': 'Unified WoPan Service',
        'timestamp': datetime.now().isoformat()
    })

def create_app():
    """Â∫îÁî®Â∑•ÂéÇÂáΩÊï∞"""
    return app


def run_with_gevent():
    """‰ΩøÁî®geventËøêË°åÊúçÂä°Âô®ÔºàÊîØÊåÅÂπ∂ÂèëÔºâ"""
    try:
        from gevent.pywsgi import WSGIServer
        logger.info("‚úÖ ‰ΩøÁî®Gevent WSGIÊúçÂä°Âô®ÔºàÊîØÊåÅÂπ∂ÂèëÔºâ")
        http_server = WSGIServer(('0.0.0.0', 8000), app)
        http_server.serve_forever()
    except ImportError:
        logger.warning("‚ö†Ô∏è GeventÊú™ÂÆâË£ÖÔºå‰ΩøÁî®FlaskÂºÄÂèëÊúçÂä°Âô®")
        app.run(host='0.0.0.0', port=8000, threaded=True)


def run_with_waitress():
    """‰ΩøÁî®waitressËøêË°åÊúçÂä°Âô®ÔºàWindowsÂèãÂ•ΩÔºâ"""
    try:
        from waitress import serve
        logger.info("‚úÖ ‰ΩøÁî®Waitress WSGIÊúçÂä°Âô®ÔºàÊîØÊåÅÂπ∂ÂèëÔºâ")
        serve(app, host='0.0.0.0', port=8000, threads=8)
    except ImportError:
        logger.warning("‚ö†Ô∏è WaitressÊú™ÂÆâË£ÖÔºåÂõûÈÄÄÂà∞ÂÖ∂‰ªñÊñπÂºè")
        run_with_gevent()


if __name__ == '__main__':
    logger.info("üöÄ ÂêØÂä®ËÅîÈÄöÁΩëÁõòÁªü‰∏ÄÊúçÂä°ÔºàÂπ∂Âèë‰ºòÂåñÁâàÔºâ")
    logger.info("=" * 60)
    logger.info("üîê ÁôªÂΩï‰ø°ÊÅØ:")
    logger.info(f"   Áî®Êà∑Âêç: {AUTH_CONFIG['username']}")
    logger.info(f"   ÂØÜÁ†Å: {AUTH_CONFIG['password']}")
    logger.info("=" * 60)
    logger.info("üåê ÊúçÂä°Âú∞ÂùÄ: http://localhost:8000")
    logger.info("üìã ÂäüËÉΩ: TokenÁÆ°ÁêÜ + Êñá‰ª∂‰∏ãËΩΩAPI + Âπ∂ÂèëÂ§ÑÁêÜ")
    logger.info("=" * 60)

    # Ê£ÄÊµãËøêË°åÁéØÂ¢ÉÂπ∂ÈÄâÊã©ÊúÄ‰Ω≥ÊúçÂä°Âô®
    if os.name == 'nt':  # Windows
        logger.info("üñ•Ô∏è Ê£ÄÊµãÂà∞WindowsÁéØÂ¢ÉÔºå‰ºòÂÖà‰ΩøÁî®Waitress")
        run_with_waitress()
    else:  # Linux/Mac
        logger.info("üêß Ê£ÄÊµãÂà∞UnixÁéØÂ¢ÉÔºå‰ºòÂÖà‰ΩøÁî®Gevent")
        run_with_gevent()
